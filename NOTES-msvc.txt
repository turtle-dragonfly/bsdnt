Internally, I have modified bsdnt to compile unser MSVC.
I am not (yet) updating this public repo accordingly because (1) those changes aren't really wanted by mainline (see: https://github.com/wbhart/bsdnt/issues/25#issuecomment-1986477565) and (2) they are intermingled with my project-specific changes currently, so not fit for public consumption.

However, I am recording some notes about the issues involved in this document, in case anyone else wants to do similar.
Feel free to ask me questions.

1. The "dword_t" problem.

The bsdnt library fundamentally represents numbers as "word_t" but from time to time uses a double-size version of that type, represented as dword_t.
On a typical modern x86_64 system, this means word_t is 64bit and dword_t must be 128bit.

However, MSVC does not provide a 128bit type.
Under GCC/clang, bsdnt relies on "__attribute__((mode(xx)))", which means the compiler fabricates a "fake" 128bit type, even if the underlying hardware does not support it directly. MSVC has no equivalent of this.

Some good discussion, requesting this feature, at: https://developercommunity.visualstudio.com/t/Support-for-128-bit-integer-type/879048

There are a few different ways to deal with this:

	1a. (easiest) Define word_t as 32bit, and dword_t as 64bit. At the time of this writing, bsdnt has some issues with this configuration, but they are not hard to fix. I plan to contribute those changes back upstream.

	1b. If compiling as C++, you can create your own "Int128" class, or somesuch, and use that for dword_t. Thanks to C++'s operator overloading, the bsdnt code should not need much updating. I have not tried this approach.

	1c. If using C++20, there may be a 128bit type in the standard. I have not tried it, but look at:
	    using int128 = std::ranges::range_difference_t<std::ranges::iota_view<long long, long long>>;

	1d. Update bsdnt to not use dword_t at all, at least under MSVC. Instead, use intrinsics such _udiv128, _addcarry_u64, etc. This is MSVC's way of exposing 128-bit math via 64-bit types.

Personally, I used (1a), which worked well enough.

Note: one downside of this is that individual bits are addressed via bit_t which is the same size as sword_t. So, with a 32bit word, one can only address 2^31 bits (256 GiB). This is almost a problem in my case, but not quite. I tried changing bit_t to be a larger type, but the changes in bsdnt core code became fairly invasive fairly quickly, so I abandoned that effort. Unfortunately most other arbitrary-precision arithmetic libaries (such as libtommath) also use 32 bits to index bits (eg: doing a bitshift), which seems odd to me. Having a 64bit type for this was one of the appeals of bsdnt. Oh well.

2. Intrinsics

The bsdnt code uses a few GCC/clang-specific compiler intrinsics for bit counting.

MSVC has some equivalents. But note that these require the underlying processor to support these operations. With GCC, if compiled for a target architechture that does not support them, an equivalent software solution will be inserted. But with MSVC, it will not. To be proper, you would run the __cpuid intrinsic to see if the system supports it. Or, just use a software in all cases. However, these are supported by reasonably old processors (ca. 2013), so I just use them unconditionally:

	#include <intrin.h>
	#define high_zero_bits(n) ((int)_lzcnt_u32(n))
	#define low_zero_bits(n) ((int)_tzcnt_u32(n))
	#define popcount_bits(n) ((int)__popcnt(n))

3. Inline assembly

The bsdnt library is designed to allow architecture-specific replacement of various functions, often implemented via assembly.
This assembly is all written in GCC style, currently.

In my MSVC build, I am not using any of this, just the plan C fallback implementation.

4. Build system

The bsdnt library has a moderately complex config/make system to query the build system for CPU type, and choose the appropriate architecture-specific details.
This is implemented in Make and Bash, so does not work on a Windows system.

I am not using this, for my MSVC build.
Instead, I just manually create any "architecutre override" files and #defines, rather than them being auto-generated by the build system.
